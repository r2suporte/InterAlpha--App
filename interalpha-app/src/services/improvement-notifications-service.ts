/**
 * Serviço de notificações automáticas para melhorias
 */

import { improvementAnalyticsService, ImprovementSuggestion } from './improvement-analytics-service'
import { feedbackService } from './feedback-service'

export interface NotificationRule {
  id: string
  name: string
  description: string
  enabled: boolean
  conditions: {
    type: 'feedback_count' | 'rating_threshold' | 'bug_pattern' | 'performance_degradation'
    threshold: number
    timeWindow: number // em minutos
    page?: string
    feature?: string
  }
  actions: {
    type: 'email' | 'slack' | 'dashboard' | 'create_improvement'
    recipients?: string[]
    template?: string
    priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  }[]
  createdAt: Date
  lastTriggered?: Date
  triggerCount: number
}

export interface NotificationEvent {
  id: string
  ruleId: string
  title: string
  message: string
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  data: Record<string, any>
  timestamp: Date
  acknowledged: boolean
  acknowledgedBy?: string
  acknowledgedAt?: Date
}

export class ImprovementNotificationsService {
  private rules: NotificationRule[] = []
  private events: NotificationEvent[] = []
  private isMonitoring = false
  private monitoringInterval?: NodeJS.Timeout

  constructor() {
    this.initializeDefaultRules()
  }

  /**
   * Inicializar regras padrão de notificação
   */
  private initializeDefaultRules() {
    this.rules = [
      {
        id: 'high_feedback_volume',
        name: 'Alto Volume de Feedback Negativo',
        description: 'Disparar quando muitos feedbacks negativos são recebidos em pouco tempo',
        enabled: true,
        conditions: {
          type: 'feedback_count',
          threshold: 5,
          timeWindow: 60 // 1 hora
        },
        actions: [
          {
            type: 'email',
            recipients: ['admin@interalpha.com', 'dev-team@interalpha.com'],
            template: 'high_negative_feedback',
            priority: 'HIGH'
          },
          {
            type: 'slack',
            priority: 'HIGH'
          },
          {
            type: 'create_improvement',
            priority: 'HIGH'
          }\n        ],\n        createdAt: new Date(),\n        triggerCount: 0\n      },\n      {\n        id: 'low_satisfaction_rating',\n        name: 'Baixa Avaliação de Satisfação',\n        description: 'Alertar quando a avaliação média cai abaixo do limite',\n        enabled: true,\n        conditions: {\n          type: 'rating_threshold',\n          threshold: 2.5,\n          timeWindow: 30 // 30 minutos\n        },\n        actions: [\n          {\n            type: 'dashboard',\n            priority: 'CRITICAL'\n          },\n          {\n            type: 'email',\n            recipients: ['product-manager@interalpha.com'],\n            priority: 'CRITICAL'\n          }\n        ],\n        createdAt: new Date(),\n        triggerCount: 0\n      },\n      {\n        id: 'bug_pattern_detected',\n        name: 'Padrão de Bug Detectado',\n        description: 'Notificar quando um padrão de bug é identificado',\n        enabled: true,\n        conditions: {\n          type: 'bug_pattern',\n          threshold: 3,\n          timeWindow: 120 // 2 horas\n        },\n        actions: [\n          {\n            type: 'email',\n            recipients: ['dev-team@interalpha.com', 'qa-team@interalpha.com'],\n            template: 'bug_pattern_alert',\n            priority: 'HIGH'\n          },\n          {\n            type: 'create_improvement',\n            priority: 'HIGH'\n          }\n        ],\n        createdAt: new Date(),\n        triggerCount: 0\n      },\n      {\n        id: 'performance_degradation',\n        name: 'Degradação de Performance',\n        description: 'Alertar sobre problemas de performance reportados',\n        enabled: true,\n        conditions: {\n          type: 'performance_degradation',\n          threshold: 2,\n          timeWindow: 15 // 15 minutos\n        },\n        actions: [\n          {\n            type: 'slack',\n            priority: 'CRITICAL'\n          },\n          {\n            type: 'email',\n            recipients: ['devops@interalpha.com'],\n            priority: 'CRITICAL'\n          }\n        ],\n        createdAt: new Date(),\n        triggerCount: 0\n      },\n      {\n        id: 'page_specific_issues',\n        name: 'Problemas Específicos de Página',\n        description: 'Monitorar problemas em páginas específicas',\n        enabled: true,\n        conditions: {\n          type: 'feedback_count',\n          threshold: 3,\n          timeWindow: 30,\n          page: '/produtos'\n        },\n        actions: [\n          {\n            type: 'dashboard',\n            priority: 'MEDIUM'\n          },\n          {\n            type: 'create_improvement',\n            priority: 'MEDIUM'\n          }\n        ],\n        createdAt: new Date(),\n        triggerCount: 0\n      }\n    ]\n  }\n\n  /**\n   * Iniciar monitoramento automático\n   */\n  startMonitoring(intervalMinutes = 5) {\n    if (this.isMonitoring) {\n      console.log('Monitoramento já está ativo')\n      return\n    }\n\n    this.isMonitoring = true\n    console.log(`Iniciando monitoramento de melhorias (intervalo: ${intervalMinutes}min)`)\n\n    this.monitoringInterval = setInterval(async () => {\n      await this.checkAllRules()\n    }, intervalMinutes * 60 * 1000)\n\n    // Executar verificação inicial\n    this.checkAllRules()\n  }\n\n  /**\n   * Parar monitoramento\n   */\n  stopMonitoring() {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval)\n      this.monitoringInterval = undefined\n    }\n    this.isMonitoring = false\n    console.log('Monitoramento de melhorias parado')\n  }\n\n  /**\n   * Verificar todas as regras ativas\n   */\n  private async checkAllRules() {\n    const activeRules = this.rules.filter(rule => rule.enabled)\n    \n    for (const rule of activeRules) {\n      try {\n        await this.checkRule(rule)\n      } catch (error) {\n        console.error(`Erro ao verificar regra ${rule.id}:`, error)\n      }\n    }\n  }\n\n  /**\n   * Verificar uma regra específica\n   */\n  private async checkRule(rule: NotificationRule) {\n    const now = new Date()\n    const timeWindowStart = new Date(now.getTime() - rule.conditions.timeWindow * 60 * 1000)\n\n    let shouldTrigger = false\n    let eventData: Record<string, any> = {}\n\n    switch (rule.conditions.type) {\n      case 'feedback_count':\n        shouldTrigger = await this.checkFeedbackCount(rule, timeWindowStart, eventData)\n        break\n      \n      case 'rating_threshold':\n        shouldTrigger = await this.checkRatingThreshold(rule, timeWindowStart, eventData)\n        break\n      \n      case 'bug_pattern':\n        shouldTrigger = await this.checkBugPattern(rule, timeWindowStart, eventData)\n        break\n      \n      case 'performance_degradation':\n        shouldTrigger = await this.checkPerformanceDegradation(rule, timeWindowStart, eventData)\n        break\n    }\n\n    if (shouldTrigger) {\n      await this.triggerRule(rule, eventData)\n    }\n  }\n\n  /**\n   * Verificar contagem de feedback\n   */\n  private async checkFeedbackCount(\n    rule: NotificationRule, \n    timeWindowStart: Date, \n    eventData: Record<string, any>\n  ): Promise<boolean> {\n    const feedbacks = await feedbackService.getFeedbackInTimeRange(\n      timeWindowStart, \n      new Date(),\n      {\n        page: rule.conditions.page,\n        feature: rule.conditions.feature,\n        rating: { lte: 2 } // Apenas feedbacks negativos\n      }\n    )\n\n    eventData.feedbackCount = feedbacks.length\n    eventData.feedbacks = feedbacks.slice(0, 5) // Primeiros 5 para contexto\n    eventData.page = rule.conditions.page\n    eventData.feature = rule.conditions.feature\n\n    return feedbacks.length >= rule.conditions.threshold\n  }\n\n  /**\n   * Verificar limite de avaliação\n   */\n  private async checkRatingThreshold(\n    rule: NotificationRule,\n    timeWindowStart: Date,\n    eventData: Record<string, any>\n  ): Promise<boolean> {\n    const feedbacks = await feedbackService.getFeedbackInTimeRange(\n      timeWindowStart,\n      new Date(),\n      {\n        page: rule.conditions.page,\n        feature: rule.conditions.feature\n      }\n    )\n\n    if (feedbacks.length === 0) return false\n\n    const avgRating = feedbacks.reduce((sum, f) => sum + f.rating, 0) / feedbacks.length\n    \n    eventData.averageRating = avgRating\n    eventData.feedbackCount = feedbacks.length\n    eventData.threshold = rule.conditions.threshold\n\n    return avgRating <= rule.conditions.threshold\n  }\n\n  /**\n   * Verificar padrão de bugs\n   */\n  private async checkBugPattern(\n    rule: NotificationRule,\n    timeWindowStart: Date,\n    eventData: Record<string, any>\n  ): Promise<boolean> {\n    const bugFeedbacks = await feedbackService.getFeedbackInTimeRange(\n      timeWindowStart,\n      new Date(),\n      {\n        type: 'bug',\n        page: rule.conditions.page,\n        feature: rule.conditions.feature\n      }\n    )\n\n    // Analisar se há padrões similares\n    const patterns = this.analyzeBugPatterns(bugFeedbacks)\n    const significantPatterns = patterns.filter(p => p.count >= rule.conditions.threshold)\n\n    eventData.bugCount = bugFeedbacks.length\n    eventData.patterns = significantPatterns\n    eventData.recentBugs = bugFeedbacks.slice(0, 3)\n\n    return significantPatterns.length > 0\n  }\n\n  /**\n   * Verificar degradação de performance\n   */\n  private async checkPerformanceDegradation(\n    rule: NotificationRule,\n    timeWindowStart: Date,\n    eventData: Record<string, any>\n  ): Promise<boolean> {\n    const performanceFeedbacks = await feedbackService.getFeedbackInTimeRange(\n      timeWindowStart,\n      new Date(),\n      {\n        keywords: ['lento', 'demora', 'carregamento', 'performance', 'travando']\n      }\n    )\n\n    eventData.performanceIssues = performanceFeedbacks.length\n    eventData.recentIssues = performanceFeedbacks.slice(0, 3)\n\n    return performanceFeedbacks.length >= rule.conditions.threshold\n  }\n\n  /**\n   * Disparar regra e executar ações\n   */\n  private async triggerRule(rule: NotificationRule, eventData: Record<string, any>) {\n    console.log(`Disparando regra: ${rule.name}`)\n\n    // Atualizar estatísticas da regra\n    rule.lastTriggered = new Date()\n    rule.triggerCount++\n\n    // Criar evento de notificação\n    const event: NotificationEvent = {\n      id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      ruleId: rule.id,\n      title: rule.name,\n      message: this.generateEventMessage(rule, eventData),\n      priority: rule.actions[0]?.priority || 'MEDIUM',\n      data: eventData,\n      timestamp: new Date(),\n      acknowledged: false\n    }\n\n    this.events.push(event)\n\n    // Executar ações\n    for (const action of rule.actions) {\n      try {\n        await this.executeAction(action, event, rule)\n      } catch (error) {\n        console.error(`Erro ao executar ação ${action.type}:`, error)\n      }\n    }\n  }\n\n  /**\n   * Executar ação específica\n   */\n  private async executeAction(\n    action: NotificationRule['actions'][0],\n    event: NotificationEvent,\n    rule: NotificationRule\n  ) {\n    switch (action.type) {\n      case 'email':\n        await this.sendEmailNotification(action, event, rule)\n        break\n      \n      case 'slack':\n        await this.sendSlackNotification(action, event, rule)\n        break\n      \n      case 'dashboard':\n        await this.createDashboardAlert(action, event, rule)\n        break\n      \n      case 'create_improvement':\n        await this.createAutomaticImprovement(action, event, rule)\n        break\n    }\n  }\n\n  /**\n   * Enviar notificação por email\n   */\n  private async sendEmailNotification(\n    action: NotificationRule['actions'][0],\n    event: NotificationEvent,\n    rule: NotificationRule\n  ) {\n    if (!action.recipients?.length) return\n\n    const emailData = {\n      to: action.recipients,\n      subject: `[${action.priority}] ${event.title}`,\n      template: action.template || 'default_improvement_alert',\n      data: {\n        event,\n        rule,\n        timestamp: event.timestamp.toLocaleString(),\n        dashboardUrl: `${process.env.NEXT_PUBLIC_APP_URL}/admin/melhorias`\n      }\n    }\n\n    // Integrar com serviço de email (SendGrid, AWS SES, etc.)\n    console.log('Enviando email:', emailData)\n  }\n\n  /**\n   * Enviar notificação para Slack\n   */\n  private async sendSlackNotification(\n    action: NotificationRule['actions'][0],\n    event: NotificationEvent,\n    rule: NotificationRule\n  ) {\n    if (!process.env.SLACK_WEBHOOK_URL) return\n\n    const color = this.getPriorityColor(action.priority)\n    const emoji = this.getPriorityEmoji(action.priority)\n\n    const payload = {\n      text: `${emoji} ${event.title}`,\n      attachments: [{\n        color,\n        title: event.title,\n        text: event.message,\n        fields: [\n          {\n            title: 'Prioridade',\n            value: action.priority,\n            short: true\n          },\n          {\n            title: 'Regra',\n            value: rule.name,\n            short: true\n          },\n          {\n            title: 'Dados',\n            value: JSON.stringify(event.data, null, 2),\n            short: false\n          }\n        ],\n        timestamp: Math.floor(event.timestamp.getTime() / 1000)\n      }]\n    }\n\n    try {\n      await fetch(process.env.SLACK_WEBHOOK_URL, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload)\n      })\n    } catch (error) {\n      console.error('Erro ao enviar notificação Slack:', error)\n    }\n  }\n\n  /**\n   * Criar alerta no dashboard\n   */\n  private async createDashboardAlert(\n    action: NotificationRule['actions'][0],\n    event: NotificationEvent,\n    rule: NotificationRule\n  ) {\n    // Implementar persistência de alertas no dashboard\n    console.log('Criando alerta no dashboard:', { action, event, rule })\n  }\n\n  /**\n   * Criar melhoria automática\n   */\n  private async createAutomaticImprovement(\n    action: NotificationRule['actions'][0],\n    event: NotificationEvent,\n    rule: NotificationRule\n  ) {\n    const improvement: Partial<ImprovementSuggestion> = {\n      title: `Auto: ${event.title}`,\n      description: `Melhoria criada automaticamente baseada na regra \"${rule.name}\": ${event.message}`,\n      priority: action.priority,\n      category: this.inferCategoryFromRule(rule),\n      impact: this.inferImpactFromPriority(action.priority),\n      effort: 'MEDIUM',\n      source: 'MONITORING',\n      status: 'PENDING',\n      metadata: {\n        autoGenerated: true,\n        ruleId: rule.id,\n        eventId: event.id,\n        triggerData: event.data\n      }\n    }\n\n    // Salvar melhoria no sistema\n    console.log('Criando melhoria automática:', improvement)\n  }\n\n  /**\n   * Obter regras ativas\n   */\n  getRules(): NotificationRule[] {\n    return this.rules\n  }\n\n  /**\n   * Obter eventos recentes\n   */\n  getRecentEvents(limit = 50): NotificationEvent[] {\n    return this.events\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n      .slice(0, limit)\n  }\n\n  /**\n   * Reconhecer evento\n   */\n  acknowledgeEvent(eventId: string, userId: string) {\n    const event = this.events.find(e => e.id === eventId)\n    if (event) {\n      event.acknowledged = true\n      event.acknowledgedBy = userId\n      event.acknowledgedAt = new Date()\n    }\n  }\n\n  /**\n   * Adicionar nova regra\n   */\n  addRule(rule: Omit<NotificationRule, 'id' | 'createdAt' | 'triggerCount'>) {\n    const newRule: NotificationRule = {\n      ...rule,\n      id: `rule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      createdAt: new Date(),\n      triggerCount: 0\n    }\n    \n    this.rules.push(newRule)\n    return newRule\n  }\n\n  /**\n   * Atualizar regra\n   */\n  updateRule(ruleId: string, updates: Partial<NotificationRule>) {\n    const ruleIndex = this.rules.findIndex(r => r.id === ruleId)\n    if (ruleIndex >= 0) {\n      this.rules[ruleIndex] = { ...this.rules[ruleIndex], ...updates }\n      return this.rules[ruleIndex]\n    }\n    return null\n  }\n\n  /**\n   * Remover regra\n   */\n  removeRule(ruleId: string) {\n    const ruleIndex = this.rules.findIndex(r => r.id === ruleId)\n    if (ruleIndex >= 0) {\n      this.rules.splice(ruleIndex, 1)\n      return true\n    }\n    return false\n  }\n\n  // Métodos auxiliares privados\n\n  private analyzeBugPatterns(bugFeedbacks: any[]) {\n    // Implementar análise de padrões em bugs\n    const patterns: { description: string; count: number; feedbacks: any[] }[] = []\n    \n    // Agrupar por palavras-chave similares\n    const keywordGroups: Record<string, any[]> = {}\n    \n    for (const feedback of bugFeedbacks) {\n      const words = feedback.message.toLowerCase().split(/\\s+/)\n      const key = words.find(word => word.length > 4) || 'unknown'\n      \n      if (!keywordGroups[key]) {\n        keywordGroups[key] = []\n      }\n      keywordGroups[key].push(feedback)\n    }\n    \n    for (const [keyword, feedbacks] of Object.entries(keywordGroups)) {\n      if (feedbacks.length >= 2) {\n        patterns.push({\n          description: `Problemas relacionados a \"${keyword}\"`,\n          count: feedbacks.length,\n          feedbacks\n        })\n      }\n    }\n    \n    return patterns\n  }\n\n  private generateEventMessage(rule: NotificationRule, eventData: Record<string, any>): string {\n    switch (rule.conditions.type) {\n      case 'feedback_count':\n        return `Recebidos ${eventData.feedbackCount} feedbacks negativos em ${rule.conditions.timeWindow} minutos${eventData.page ? ` na página ${eventData.page}` : ''}`\n      \n      case 'rating_threshold':\n        return `Avaliação média caiu para ${eventData.averageRating?.toFixed(1)}/5 (limite: ${rule.conditions.threshold})`\n      \n      case 'bug_pattern':\n        return `Detectado padrão de bugs: ${eventData.patterns?.map((p: any) => p.description).join(', ')}`\n      \n      case 'performance_degradation':\n        return `${eventData.performanceIssues} problemas de performance reportados`\n      \n      default:\n        return 'Condição de alerta atingida'\n    }\n  }\n\n  private getPriorityColor(priority: string): string {\n    switch (priority) {\n      case 'CRITICAL': return 'danger'\n      case 'HIGH': return 'warning'\n      case 'MEDIUM': return 'good'\n      case 'LOW': return '#36a64f'\n      default: return '#36a64f'\n    }\n  }\n\n  private getPriorityEmoji(priority: string): string {\n    switch (priority) {\n      case 'CRITICAL': return '🚨'\n      case 'HIGH': return '⚠️'\n      case 'MEDIUM': return '📢'\n      case 'LOW': return 'ℹ️'\n      default: return '📢'\n    }\n  }\n\n  private inferCategoryFromRule(rule: NotificationRule): ImprovementSuggestion['category'] {\n    if (rule.conditions.type === 'bug_pattern') return 'BUG'\n    if (rule.conditions.type === 'performance_degradation') return 'PERFORMANCE'\n    if (rule.conditions.type === 'rating_threshold') return 'UX'\n    return 'FEATURE'\n  }\n\n  private inferImpactFromPriority(priority: string): ImprovementSuggestion['impact'] {\n    switch (priority) {\n      case 'CRITICAL':\n      case 'HIGH':\n        return 'HIGH'\n      case 'MEDIUM':\n        return 'MEDIUM'\n      case 'LOW':\n        return 'LOW'\n      default:\n        return 'MEDIUM'\n    }\n  }\n}\n\n// Singleton instance\nexport const improvementNotificationsService = new ImprovementNotificationsService()